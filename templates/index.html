<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Geva Kipper | Algorithmic Art Portfolio</title>
  <style>
    :root {
      --bg-dark: #050c1a;
      --bg-navy: #0f1b33;
      --accent-cyan: #00ffff;
      --accent-magenta: #ff00ff;
      --accent-blue: #0088ff;
      --white: #ffffff;
      --terminal-bg: rgba(10, 20, 40, 0.85);
      --terminal-border: rgba(60, 100, 170, 0.5);
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    @font-face {
      font-family: 'JetBrains Mono';
      src: url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');
    }

    body {
      font-family: 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, var(--bg-navy), var(--bg-dark));
      color: var(--white);
      overflow-x: hidden;
      min-height: 100vh;
      line-height: 1.6;
    }
    
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      pointer-events: none;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
    }
    
    /* Header Styles */
    header {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      position: relative;
    }
    
    .header-content {
      position: relative;
      z-index: 2;
    }
    
    h1 {
      font-size: 4rem;
      margin-bottom: 1rem;
      position: relative;
      font-family: 'JetBrains Mono', monospace;
      opacity: 0;
      animation: fadeIn 1s forwards;
      animation-delay: 0.5s;
    }
    
    h1::after {
      content: '';
      position: absolute;
      width: 1px;
      height: 1.5rem;
      background-color: var(--accent-cyan);
      right: -1.5rem;
      top: 50%;
      transform: translateY(-50%);
      animation: blink 1s infinite;
    }
    
    .subtitle {
      font-size: 1.5rem;
      margin-bottom: 1rem;
      color: var(--accent-blue);
      opacity: 0;
      animation: fadeIn 1s forwards;
      animation-delay: 1s;
    }
    
    .description {
      font-size: 1.2rem;
      max-width: 600px;
      margin-bottom: 2rem;
      opacity: 0;
      animation: fadeIn 1s forwards;
      animation-delay: 1.5s;
    }
    
    .timestamp {
      font-family: 'JetBrains Mono', monospace;
      color: var(--accent-magenta);
      margin-bottom: 3rem;
      opacity: 0;
      animation: fadeIn 1s forwards;
      animation-delay: 2s;
    }
    
    /* Navigation Command Bar */
    .command-nav {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      padding: 1rem 2rem;
      background: rgba(5, 10, 20, 0.8);
      backdrop-filter: blur(5px);
      display: flex;
      justify-content: center;
      z-index: 100;
      transform: translateY(-100%);
      opacity: 0;
      transition: transform 0.5s, opacity 0.5s;
    }
    
    .command-nav.visible {
      transform: translateY(0);
      opacity: 1;
    }
    
    .command-nav button {
      background: none;
      border: none;
      color: var(--white);
      font-family: 'JetBrains Mono', monospace;
      font-size: 1rem;
      margin: 0 1rem;
      padding: 0.5rem 1rem;
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }
    
    .command-nav button::before {
      content: '>';
      margin-right: 0.5rem;
      color: var(--accent-cyan);
    }
    
    .command-nav button:hover {
      color: var(--accent-cyan);
    }
    
    .command-nav button:hover::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 1px;
      background: linear-gradient(90deg, transparent, var(--accent-cyan), transparent);
      animation: scanLine 2s infinite;
    }
    
    /* Project Section Styles */
    .projects {
      margin-top: 4rem;
    }
    
    .project {
      background: var(--terminal-bg);
      border: 1px solid var(--terminal-border);
      border-radius: 0.5rem;
      padding: 1.5rem;
      margin-bottom: 3rem;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
      position: relative;
      overflow: hidden;
      transform: translateY(50px);
      opacity: 0;
      transition: transform 0.5s, opacity 0.5s;
    }
    
    .project.visible {
      transform: translateY(0);
      opacity: 1;
    }
    
    .project::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2rem;
      background: rgba(30, 40, 60, 0.5);
      border-bottom: 1px solid var(--terminal-border);
      border-radius: 0.5rem 0.5rem 0 0;
      display: flex;
      align-items: center;
      padding: 0 1rem;
    }
    
    .project-content {
      margin-top: 1.5rem;
    }
    
    .project-title {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.8rem;
      margin-bottom: 1rem;
      color: var(--accent-cyan);
      position: relative;
      display: inline-block;
    }
    
    .project-title::before {
      content: '> ';
      color: var(--accent-magenta);
    }
    
    .project-description {
      margin-bottom: 1.5rem;
      position: relative;
      padding-left: 1rem;
    }
    
    .project-links {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin-top: 1rem;
    }
    
    .project-link {
      color: var(--accent-blue);
      text-decoration: none;
      font-family: 'JetBrains Mono', monospace;
      position: relative;
      padding-left: 1.5rem;
      transition: color 0.3s;
    }
    
    .project-link::before {
      content: 'â†’';
      position: absolute;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      color: var(--accent-magenta);
    }
    
    .project-link:hover {
      color: var(--accent-cyan);
    }
    
    /* Visualization areas */
    .visualization-area {
      height: 200px;
      margin: 1.5rem 0;
      border: 1px dashed rgba(255, 255, 255, 0.3);
      border-radius: 0.25rem;
      position: relative;
      overflow: hidden;
    }
    
    .visualization-area canvas {
      position: absolute;
      width: 100%;
      height: 100%;
    }
    
    /* Contact Section */
    .contact-section {
      margin-top: 3rem;
      padding-bottom: 5rem;
    }
    
    .contact-title {
      font-family: 'JetBrains Mono', monospace;
      font-size: 2rem;
      margin-bottom: 2rem;
      color: var(--accent-cyan);
    }
    
    .social-links {
      display: flex;
      flex-wrap: wrap;
      gap: 1.5rem;
      margin-bottom: 2rem;
    }
    
    .social-link {
      display: flex;
      align-items: center;
      color: var(--white);
      text-decoration: none;
      font-family: 'JetBrains Mono', monospace;
      transition: transform 0.3s, color 0.3s;
      position: relative;
    }
    
    .social-link::before {
      content: '>';
      margin-right: 0.5rem;
      color: var(--accent-magenta);
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .social-link:hover {
      color: var(--accent-cyan);
      transform: translateX(5px);
    }
    
    .social-link:hover::before {
      opacity: 1;
    }
    
    /* Export Art Button */
    .export-btn {
      background: linear-gradient(90deg, var(--accent-blue), var(--accent-magenta));
      border: none;
      border-radius: 0.25rem;
      padding: 0.75rem 1.5rem;
      color: var(--white);
      font-family: 'JetBrains Mono', monospace;
      cursor: pointer;
      transition: transform 0.3s, box-shadow 0.3s;
      margin-bottom: 2rem;
    }
    
    .export-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 255, 255, 0.3);
    }
    
    /* Footer */
    footer {
      background: rgba(5, 10, 20, 0.8);
      padding: 2rem;
      text-align: center;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
      border-top: 1px solid var(--terminal-border);
    }
    
    .timer {
      color: var(--accent-cyan);
      margin: 1rem 0;
    }
    
    .credits {
      color: rgba(255, 255, 255, 0.6);
    }
    
    /* Animations */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    @keyframes blink {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0;
      }
    }
    
    @keyframes scanLine {
      0% {
        transform: translateX(-100%);
      }
      100% {
        transform: translateX(100%);
      }
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      h1 {
        font-size: 2.5rem;
      }
      
      .subtitle {
        font-size: 1.2rem;
      }
      
      .command-nav {
        flex-wrap: wrap;
        padding: 0.5rem;
      }
      
      .command-nav button {
        margin: 0.25rem;
        font-size: 0.9rem;
      }
      
      .visualization-area {
        height: 150px;
      }
      
      .project-title {
        font-size: 1.5rem;
      }
    }
    
    @media (max-width: 480px) {
      .container {
        padding: 1rem;
      }
      
      h1 {
        font-size: 2rem;
      }
      
      .social-links {
        flex-direction: column;
        gap: 1rem;
      }
    }
  </style>
</head>
<body>
  <canvas id="background-canvas"></canvas>
  
  <nav class="command-nav">
    <button data-target="header">home</button>
    <button data-target="glglstats">glglStats</button>
    <button data-target="ahuzat-dibuk">ahuzatDibuk</button>
    <button data-target="part-orienting">partOrienting</button>
    <button data-target="portfolio">portfolio</button>
    <button data-target="contact-section">contact</button>
  </nav>
  
  <div class="container">
    <header id="header">
      <div class="header-content">
        <h1 id="name"></h1>
        <p class="subtitle">Software Engineer at Google</p>
        <p class="description">This portfolio is dynamically redesigned daily by AI. It generates unique algorithmic art based on your interactions.</p>
        <p class="timestamp">Last redesigned: <span id="last-update"></span></p>
      </div>
    </header>
    
    <section class="projects">
      <div class="project" id="glglstats">
        <div class="project-content">
          <h2 class="project-title">GlglStats</h2>
          <p class="project-description">A statistical analysis tool implementing LZ77 compression algorithm for pattern detection and visualization.</p>
          <div id="glglstats-viz" class="visualization-area"></div>
          <div class="project-links">
            <a href="https://glglstats.onrender.com/" class="project-link" target="_blank">Visit Website</a>
            <a href="https://www.youtube.com/watch?v=jrKAtOsj1Lo" class="project-link" target="_blank">PyData Presentation</a>
          </div>
        </div>
      </div>
      
      <div class="project" id="ahuzat-dibuk">
        <div class="project-content">
          <h2 class="project-title">Ahuzat Dibuk</h2>
          <p class="project-description">Parking density visualization, analyzing and predicting parking patterns in Tel Aviv neighborhoods.</p>
          <div id="ahuzat-dibuk-viz" class="visualization-area"></div>
          <div class="project-links">
            <a href="https://www.facebook.com/groups/secrettelaviv/posts/10159636301195943" class="project-link" target="_blank">Original Publication</a>
            <a href="https://13tv.co.il/item/news/domestic/internal/parking-902956407/" class="project-link" target="_blank">13TV News Coverage</a>
            <a href="https://www.mako.co.il/nexter-news/Article-ae43964b891bf71027.htm" class="project-link" target="_blank">Mako News Article</a>
          </div>
        </div>
      </div>
      
      <div class="project" id="part-orienting">
        <div class="project-content">
          <h2 class="project-title">2D Part Orienting</h2>
          <p class="project-description">Computational geometry algorithm for optimizing the orientation of 2D parts, reducing processing time and complexity.</p>
          <div id="part-orienting-viz" class="visualization-area"></div>
          <div class="project-links">
            <a href="https://www.cgl.cs.tau.ac.il/projects/2d-part-orienting/" class="project-link" target="_blank">Project Details</a>
          </div>
        </div>
      </div>
      
      <div class="project" id="portfolio">
        <div class="project-content">
          <h2 class="project-title">Portfolio Website</h2>
          <p class="project-description">Self-referential algorithmic visualization of this portfolio's code structure, dynamically responsive to user interactions.</p>
          <div id="portfolio-viz" class="visualization-area"></div>
          <div class="project-links">
            <a href="https://portfolio-dor1.onrender.com/" class="project-link" target="_blank">Visit Portfolio</a>
          </div>
        </div>
      </div>
    </section>
    
    <section class="contact-section" id="contact-section">
      <h2 class="contact-title">Connect</h2>
      <div class="social-links">
        <a href="https://github.com/gevak" class="social-link" target="_blank">github.com/gevak</a>
        <a href="https://linkedin.com/in/gevakip" class="social-link" target="_blank">linkedin.com/in/gevakip</a>
        <a href="https://facebook.com/geva.kipper" class="social-link" target="_blank">facebook.com/geva.kipper</a>
      </div>
      
      <button class="export-btn" id="export-btn">Export Your Unique Art</button>
      
      <div id="contact-viz" class="visualization-area"></div>
    </section>
  </div>
  
  <footer>
    <p class="timer">Portfolio running for: <span id="runtime-counter">00:00:00:00</span></p>
    <p class="credits">Algorithm + Art + Interface designed by AI</p>
  </footer>
  
  <script>
    // Background Canvas Setup
    const canvas = document.getElementById('background-canvas');
    const ctx = canvas.getContext('2d');
    
    // Set canvas dimensions
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Particle System
    class Particle {
      constructor() {
        this.reset();
      }
      
      reset() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.size = Math.random() * 3 + 1;
        this.speedX = Math.random() * 1 - 0.5;
        this.speedY = Math.random() * 1 - 0.5;
        this.color = this.getRandomColor();
        this.life = Math.random() * 200 + 50;
        this.maxLife = this.life;
      }
      
      getRandomColor() {
        const colors = ['#00ffff', '#ff00ff', '#0088ff'];
        return colors[Math.floor(Math.random() * colors.length)];
      }
      
      update() {
        this.x += this.speedX;
        this.y += this.speedY;
        this.life--;
        
        if (this.life <= 0 || this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
          this.reset();
        }
      }
      
      draw() {
        const opacity = this.life / this.maxLife;
        ctx.fillStyle = this.color + Math.floor(opacity * 255).toString(16).padStart(2, '0');
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
      }
    }
    
    // Create particles
    const particles = [];
    const particleCount = Math.min(window.innerWidth, window.innerHeight) / 10;
    
    for (let i = 0; i < particleCount; i++) {
      particles.push(new Particle());
    }
    
    // Line connections between particles
    function drawConnections() {
      const maxDistance = 100;
      
      for (let i = 0; i < particles.length; i++) {
        for (let j = i + 1; j < particles.length; j++) {
          const dx = particles[i].x - particles[j].x;
          const dy = particles[i].y - particles[j].y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < maxDistance) {
            const opacity = 1 - distance / maxDistance;
            ctx.strokeStyle = `rgba(0, 255, 255, ${opacity * 0.15})`;
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(particles[i].x, particles[i].y);
            ctx.lineTo(particles[j].x, particles[j].y);
            ctx.stroke();
          }
        }
      }
    }
    
    // Mouse interaction
    let mouse = {
      x: undefined,
      y: undefined,
      radius: 150
    };
    
    window.addEventListener('mousemove', function(e) {
      mouse.x = e.x;
      mouse.y = e.y;
    });
    
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw connections first (behind particles)
      drawConnections();
      
      // Update and draw particles
      for (let i = 0; i < particles.length; i++) {
        particles[i].update();
        particles[i].draw();
        
        // Mouse interaction
        if (mouse.x && mouse.y) {
          const dx = particles[i].x - mouse.x;
          const dy = particles[i].y - mouse.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < mouse.radius) {
            const forceX = dx / distance;
            const forceY = dy / distance;
            const force = (mouse.radius - distance) / mouse.radius;
            
            particles[i].speedX += forceX * force * 0.2;
            particles[i].speedY += forceY * force * 0.2;
          }
        }
      }
      
      // Draw code flow patterns
      drawCodeFlow();
    }
    
    // Simulate code flows across the screen
    function drawCodeFlow() {
      // Only add new flow lines occasionally
      if (Math.random() < 0.01) {
        let x = Math.random() * canvas.width;
        let y = 0;
        let length = Math.random() * 50 + 10;
        let speed = Math.random() * 2 + 1;
        let opacity = Math.random() * 0.5 + 0.2;
        
        codeFlows.push({ x, y, length, speed, opacity });
      }
      
      // Draw and update existing flow lines
      for (let i = 0; i < codeFlows.length; i++) {
        const flow = codeFlows[i];
        
        ctx.strokeStyle = `rgba(0, 255, 255, ${flow.opacity})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(flow.x, flow.y);
        ctx.lineTo(flow.x, flow.y + flow.length);
        ctx.stroke();
        
        // Update position
        flow.y += flow.speed;
        
        // Remove if off-screen
        if (flow.y > canvas.height) {
          codeFlows.splice(i, 1);
          i--;
        }
      }
    }
    
    const codeFlows = [];
    
    // Visualization for each project
    function setupProjectVisualizations() {
      // GlglStats Visualization - Waveforms and LZ77 Compression
      const glglStatsCanvas = document.createElement('canvas');
      const glglStatsCtx = glglStatsCanvas.getContext('2d');
      const glglStatsViz = document.getElementById('glglstats-viz');
      glglStatsViz.appendChild(glglStatsCanvas);
      
      glglStatsCanvas.width = glglStatsViz.offsetWidth;
      glglStatsCanvas.height = glglStatsViz.offsetHeight;
      
      function animateGlglStats() {
        requestAnimationFrame(animateGlglStats);
        glglStatsCtx.clearRect(0, 0, glglStatsCanvas.width, glglStatsCanvas.height);
        
        // Draw compression waveform
        glglStatsCtx.strokeStyle = '#00ffff';
        glglStatsCtx.lineWidth = 2;
        glglStatsCtx.beginPath();
        
        const amplitude = 40;
        const frequency = 0.01;
        const compression = Math.sin(Date.now() * 0.001) * 0.5 + 0.5; // Compression factor
        
        for (let x = 0; x < glglStatsCanvas.width; x++) {
          const y = glglStatsCanvas.height / 2 + 
                   Math.sin(x * frequency * compression) * amplitude * 
                   Math.cos(x * frequency * 0.3);
          
          if (x === 0) {
            glglStatsCtx.moveTo(x, y);
          } else {
            glglStatsCtx.lineTo(x, y);
          }
        }
        
        glglStatsCtx.stroke();
        
        // Draw compression indicators
        const compressionWidth = glglStatsCanvas.width * (0.3 + compression * 0.4);
        glglStatsCtx.fillStyle = 'rgba(255, 0, 255, 0.3)';
        glglStatsCtx.fillRect(0, glglStatsCanvas.height - 20, compressionWidth, 10);
        
        glglStatsCtx.fillStyle = '#ffffff';
        glglStatsCtx.font = '10px monospace';
        glglStatsCtx.fillText(`Compression: ${Math.floor(compression * 100)}%`, 10, glglStatsCanvas.height - 25);
      }
      
      animateGlglStats();
      
      // Ahuzat Dibuk Visualization - Parking Heatmap
      const ahuzatCanvas = document.createElement('canvas');
      const ahuzatCtx = ahuzatCanvas.getContext('2d');
      const ahuzatViz = document.getElementById('ahuzat-dibuk-viz');
      ahuzatViz.appendChild(ahuzatCanvas);
      
      ahuzatCanvas.width = ahuzatViz.offsetWidth;
      ahuzatCanvas.height = ahuzatViz.offsetHeight;
      
      // Create parking spot grid
      const gridSize = 12;
      const spotSize = Math.min(
        ahuzatCanvas.width / gridSize, 
        ahuzatCanvas.height / gridSize
      );
      
      const parkingSpots = [];
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          parkingSpots.push({
            x: j * spotSize + spotSize/2,
            y: i * spotSize + spotSize/2,
            occupied: Math.random() > 0.5,
            density: Math.random()
          });
        }
      }
      
      ahuzatViz.addEventListener('mousemove', function(e) {
        const rect = ahuzatCanvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // Update densities based on mouse position
        parkingSpots.forEach(spot => {
          const dx = spot.x - mouseX;
          const dy = spot.y - mouseY;
          const distance = Math.sqrt(dx*dx + dy*dy);
          
          if (distance < spotSize * 3) {
            spot.density = Math.min(1, spot.density + 0.02);
            spot.occupied = Math.random() > 0.3;
          } else {
            spot.density = Math.max(0, spot.density - 0.01);
          }
        });
      });
      
      function animateAhuzat() {
        requestAnimationFrame(animateAhuzat);
        ahuzatCtx.clearRect(0, 0, ahuzatCanvas.width, ahuzatCanvas.height);
        
        // Draw streets
        ahuzatCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        ahuzatCtx.lineWidth = 1;
        
        for (let i = 0; i <= gridSize; i++) {
          const pos = i * spotSize;
          
          // Horizontal streets
          ahuzatCtx.beginPath();
          ahuzatCtx.moveTo(0, pos);
          ahuzatCtx.lineTo(ahuzatCanvas.width, pos);
          ahuzatCtx.stroke();
          
          // Vertical streets
          ahuzatCtx.beginPath();
          ahuzatCtx.moveTo(pos, 0);
          ahuzatCtx.lineTo(pos, ahuzatCanvas.height);
          ahuzatCtx.stroke();
        }
        
        // Draw parking spots
        parkingSpots.forEach(spot => {
          const halfSize = spotSize * 0.4;
          
          // Change color based on density
          if (spot.occupied) {
            const redValue = Math.floor(255 * spot.density);
            ahuzatCtx.fillStyle = `rgba(${redValue}, 50, 255, 0.7)`;
          } else {
            ahuzatCtx.fillStyle = `rgba(0, 150, 255, 0.3)`;
          }
          
          ahuzatCtx.fillRect(
            spot.x - halfSize, 
            spot.y - halfSize, 
            halfSize * 2, 
            halfSize * 2
          );
        });
        
        // Draw heatmap overlay
        for (let x = 0; x < ahuzatCanvas.width; x += 5) {
          for (let y = 0; y < ahuzatCanvas.height; y += 5) {
            let totalDensity = 0;
            let count = 0;
            
            parkingSpots.forEach(spot => {
              const dx = spot.x - x;
              const dy = spot.y - y;
              const distance = Math.sqrt(dx*dx + dy*dy);
              
              if (distance < spotSize * 2) {
                totalDensity += spot.density * (1 - distance / (spotSize * 2));
                count++;
              }
            });
            
            if (count > 0) {
              const avgDensity = totalDensity / count;
              ahuzatCtx.fillStyle = `rgba(255, 0, 150, ${avgDensity * 0.1})`;
              ahuzatCtx.fillRect(x, y, 5, 5);
            }
          }
        }
        
        // Stats overlay
        ahuzatCtx.fillStyle = '#ffffff';
        ahuzatCtx.font = '10px monospace';
        const occupiedCount = parkingSpots.filter(spot => spot.occupied).length;
        const occupancy = Math.floor((occupiedCount / parkingSpots.length) * 100);
        ahuzatCtx.fillText(`Parking Occupancy: ${occupancy}%`, 10, 15);
      }
      
      animateAhuzat();
      
      // 2D Part Orienting Visualization
      const partOrientingCanvas = document.createElement('canvas');
      const partOrientingCtx = partOrientingCanvas.getContext('2d');
      const partOrientingViz = document.getElementById('part-orienting-viz');
      partOrientingViz.appendChild(partOrientingCanvas);
      
      partOrientingCanvas.width = partOrientingViz.offsetWidth;
      partOrientingCanvas.height = partOrientingViz.offsetHeight;
      
      let polygon = [
        {x: 0, y: -50},
        {x: 30, y: -15},
        {x: 50, y: 30},
        {x: 0, y: 50},
        {x: -40, y: 20},
        {x: -30, y: -30}
      ];
      
      let rotation = 0;
      let targetRotation = 0;
      let isReorienting = false;
      
      partOrientingViz.addEventListener('click', function() {
        if (!isReorienting) {
          isReorienting = true;
          targetRotation = rotation + Math.PI * 2 * (Math.floor(Math.random() * 4) + 1) / 4;
        }
      });
      
      function animatePartOrienting() {
        requestAnimationFrame(animatePartOrienting);
        partOrientingCtx.clearRect(0, 0, partOrientingCanvas.width, partOrientingCanvas.height);
        
        // Update rotation if reorienting
        if (isReorienting) {
          const diff = targetRotation - rotation;
          if (Math.abs(diff) < 0.01) {
            rotation = targetRotation;
            isReorienting = false;
          } else {
            rotation += diff * 0.05;
          }
        } else {
          // Slight movement when idle
          rotation += Math.sin(Date.now() * 0.001) * 0.005;
        }
        
        // Draw coordinate system
        partOrientingCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        partOrientingCtx.lineWidth = 1;
        
        const centerX = partOrientingCanvas.width / 2;
        const centerY = partOrientingCanvas.height / 2;
        
        partOrientingCtx.beginPath();
        partOrientingCtx.moveTo(centerX - 100, centerY);
        partOrientingCtx.lineTo(centerX + 100, centerY);
        partOrientingCtx.stroke();
        
        partOrientingCtx.beginPath();
        partOrientingCtx.moveTo(centerX, centerY - 100);
        partOrientingCtx.lineTo(centerX, centerY + 100);
        partOrientingCtx.stroke();
        
        // Draw polygon
        partOrientingCtx.save();
        partOrientingCtx.translate(centerX, centerY);
        partOrientingCtx.rotate(rotation);
        
        partOrientingCtx.strokeStyle = '#00ffff';
        partOrientingCtx.lineWidth = 2;
        partOrientingCtx.fillStyle = 'rgba(0, 255, 255, 0.2)';
        
        partOrientingCtx.beginPath();
        partOrientingCtx.moveTo(polygon[0].x, polygon[0].y);
        
        for (let i = 1; i < polygon.length; i++) {
          partOrientingCtx.lineTo(polygon[i].x, polygon[i].y);
        }
        
        partOrientingCtx.closePath();
        partOrientingCtx.fill();
        partOrientingCtx.stroke();
        
        // Draw center dot
        partOrientingCtx.fillStyle = '#ff00ff';
        partOrientingCtx.beginPath();
        partOrientingCtx.arc(0, 0, 3, 0, Math.PI * 2);
        partOrientingCtx.fill();
        
        partOrientingCtx.restore();
        
        // Draw angle indicator
        const normalizedAngle = (rotation % (Math.PI * 2) + Math.PI * 2) % (Math.PI * 2);
        const angleDegrees = Math.floor(normalizedAngle * 180 / Math.PI);
        
        partOrientingCtx.fillStyle = '#ffffff';
        partOrientingCtx.font = '10px monospace';
        partOrientingCtx.fillText(`Orientation: ${angleDegrees}Â°`, 10, 15);
        
        if (isReorienting) {
          partOrientingCtx.fillStyle = '#ff00ff';
          partOrientingCtx.fillText('Reorienting...', 10, 30);
        } else {
          partOrientingCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
          partOrientingCtx.fillText('Click to reorient', 10, 30);
        }
      }
      
      animatePartOrienting();
      
      // Portfolio Visualization - Code Structure
      const portfolioCanvas = document.createElement('canvas');
      const portfolioCtx = portfolioCanvas.getContext('2d');
      const portfolioViz = document.getElementById('portfolio-viz');
      portfolioViz.appendChild(portfolioCanvas);
      
      portfolioCanvas.width = portfolioViz.offsetWidth;
      portfolioCanvas.height = portfolioViz.offsetHeight;
      
      const codeStructure = [
        { name: 'HTML', size: 0.3, color: '#ff9900' },
        { name: 'CSS', size: 0.45, color: '#00ffff' },
        { name: 'JavaScript', size: 0.25, color: '#ffff00' }
      ];
      
      let highlightedSection = null;
      let codeLines = [];
      
      // Generate code line effects
      for (let i = 0; i < 20; i++) {
        codeLines.push({
          x: Math.random() * portfolioCanvas.width,
          y: Math.random() * portfolioCanvas.height,
          width: Math.random() * 100 + 20,
          section: codeStructure[Math.floor(Math.random() * codeStructure.length)],
          opacity: Math.random() * 0.7 + 0.3
        });
      }
      
      portfolioViz.addEventListener('mousemove', function(e) {
        const rect = portfolioCanvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // Determine highlighted section based on position
        const centerX = portfolioCanvas.width / 2;
        const centerY = portfolioCanvas.height / 2;
        const dx = mouseX - centerX;
        const dy = mouseY - centerY;
        const angle = Math.atan2(dy, dx);
        const sectionAngle = Math.PI * 2 / codeStructure.length;
        
        // Map angle to section
        let sectionIndex = Math.floor(((angle + Math.PI) / sectionAngle) % codeStructure.length);
        highlightedSection = codeStructure[sectionIndex];
        
        // Create new code line at mouse position occasionally
        if (Math.random() < 0.1) {
          codeLines.push({
            x: mouseX,
            y: mouseY,
            width: Math.random() * 80 + 20,
            section: highlightedSection,
            opacity: 0.8
          });
          
          // Limit number of code lines
          if (codeLines.length > 30) {
            codeLines.shift();
          }
        }
      });
      
      function animatePortfolio() {
        requestAnimationFrame(animatePortfolio);
        portfolioCtx.clearRect(0, 0, portfolioCanvas.width, portfolioCanvas.height);
        
        const centerX = portfolioCanvas.width / 2;
        const centerY = portfolioCanvas.height / 2;
        const radius = Math.min(centerX, centerY) * 0.8;
        
        // Draw code structure pie chart
        let startAngle = 0;
        codeStructure.forEach(section => {
          const sliceAngle = Math.PI * 2 * section.size;
          
          portfolioCtx.beginPath();
          portfolioCtx.moveTo(centerX, centerY);
          portfolioCtx.arc(centerX, centerY, radius, startAngle, startAngle + sliceAngle);
          portfolioCtx.closePath();
          
          // Highlight active section
          if (highlightedSection && section.name === highlightedSection.name) {
            portfolioCtx.fillStyle = section.color;
          } else {
            const colorValue = section.color + '80'; // Add 50% opacity
            portfolioCtx.fillStyle = colorValue;
          }
          portfolioCtx.fill();
          
          // Draw section label
          const labelAngle = startAngle + sliceAngle / 2;
          const labelX = centerX + Math.cos(labelAngle) * (radius * 0.7);
          const labelY = centerY + Math.sin(labelAngle) * (radius * 0.7);
          
          portfolioCtx.fillStyle = '#ffffff';
          portfolioCtx.font = '10px monospace';
          portfolioCtx.textAlign = 'center';
          portfolioCtx.textBaseline = 'middle';
          portfolioCtx.fillText(section.name, labelX, labelY);
          
          startAngle += sliceAngle;
        });
        
        // Draw code lines
        codeLines.forEach((line, index) => {
          portfolioCtx.fillStyle = `${line.section.color}${Math.floor(line.opacity * 255).toString(16).padStart(2, '0')}`;
          portfolioCtx.fillRect(line.x, line.y, line.width, 1);
          
          // Fade out code lines
          line.opacity -= 0.005;
          if (line.opacity <= 0) {
            codeLines.splice(index, 1);
          }
        });
      }
      
      animatePortfolio();
      
      // Contact Visualization
      const contactCanvas = document.createElement('canvas');
      const contactCtx = contactCanvas.getContext('2d');
      const contactViz = document.getElementById('contact-viz');
      contactViz.appendChild(contactCanvas);
      
      contactCanvas.width = contactViz.offsetWidth;
      contactCanvas.height = contactViz.offsetHeight;
      
      const nodes = [];
      const nodeCount = 5; // One for each social platform plus two extras
      
      // Create nodes for social networks
      for (let i = 0; i < nodeCount; i++) {
        nodes.push({
          x: Math.random() * contactCanvas.width,
          y: Math.random() * contactCanvas.height,
          speedX: Math.random() * 1 - 0.5,
          speedY: Math.random() * 1 - 0.5,
          size: Math.random() * 5 + 10,
          color: i < 3 ? 
                 ['#00ffff', '#ff00ff', '#0088ff'][i] : 
                 `hsl(${Math.random() * 360}, 100%, 70%)`
        });
      }
      
      function animateContact() {
        requestAnimationFrame(animateContact);
        contactCtx.clearRect(0, 0, contactCanvas.width, contactCanvas.height);
        
        // Draw connections between nodes
        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            const dx = nodes[i].x - nodes[j].x;
            const dy = nodes[i].y - nodes[j].y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 150) {
              const opacity = 1 - distance / 150;
              contactCtx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.5})`;
              contactCtx.lineWidth = opacity * 2;
              contactCtx.beginPath();
              contactCtx.moveTo(nodes[i].x, nodes[i].y);
              contactCtx.lineTo(nodes[j].x, nodes[j].y);
              contactCtx.stroke();
              
              // Draw connection data packets
              const packetCount = Math.floor(opacity * 3);
              for (let k = 0; k < packetCount; k++) {
                const progress = (Date.now() / 1000 + k / packetCount) % 1;
                const packetX = nodes[i].x + dx * progress;
                const packetY = nodes[i].y + dy * progress;
                
                contactCtx.fillStyle = nodes[i].color;
                contactCtx.beginPath();
                contactCtx.arc(packetX, packetY, 2, 0, Math.PI * 2);
                contactCtx.fill();
              }
            }
          }
        }
        
        // Draw and update nodes
        nodes.forEach((node, index) => {
          // Draw glow effect
          const gradient = contactCtx.createRadialGradient(
            node.x, node.y, node.size * 0.5,
            node.x, node.y, node.size * 2
          );
          gradient.addColorStop(0, node.color);
          gradient.addColorStop(1, 'transparent');
          
          contactCtx.fillStyle = gradient;
          contactCtx.beginPath();
          contactCtx.arc(node.x, node.y, node.size * 2, 0, Math.PI * 2);
          contactCtx.fill();
          
          // Draw node
          contactCtx.fillStyle = '#ffffff';
          contactCtx.beginPath();
          contactCtx.arc(node.x, node.y, node.size, 0, Math.PI * 2);
          contactCtx.fill();
          
          // Add platform name if it's one of the social nodes
          if (index < 3) {
            const platforms = ['GitHub', 'LinkedIn', 'Facebook'];
            contactCtx.fillStyle = '#ffffff';
            contactCtx.font = '10px monospace';
            contactCtx.textAlign = 'center';
            contactCtx.fillText(platforms[index], node.x, node.y + node.size + 10);
          }
          
          // Update position
          node.x += node.speedX;
          node.y += node.speedY;
          
          // Bounce off edges
          if (node.x < node.size || node.x > contactCanvas.width - node.size) {
            node.speedX *= -1;
          }
          if (node.y < node.size || node.y > contactCanvas.height - node.size) {
            node.speedY *= -1;
          }
        });
      }
      
      animateContact();
    }
    
    // Start animation
    animate();
    requestAnimationFrame(() => {
      setupProjectVisualizations();
    });
    
    // Header typing animation
    const nameElement = document.getElementById('name');
    const fullName = "Geva Kipper";
    let nameIndex = 0;
    
    function typeWriter() {
      if (nameIndex < fullName.length) {
        nameElement.textContent += fullName.charAt(nameIndex);
        nameIndex++;
        setTimeout(typeWriter, 100);
      }
    }
    
    setTimeout(typeWriter, 1000);
    
    // Last updated timestamp
    const lastUpdateElement = document.getElementById('last-update');
    const updateDate = new Date('2025-04-04T01:02:04');
    lastUpdateElement.textContent = updateDate.toLocaleString();
    
    // Runtime counter
    const runtimeCounter = document.getElementById('runtime-counter');
    const startDate = new Date('2025-04-04T01:02:04');
    
    function updateRuntimeCounter() {
      const now = new Date();
      const elapsed = now - startDate;
      
      const days = Math.floor(elapsed / (24 * 60 * 60 * 1000));
      const hours = Math.floor((elapsed % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000));
      const minutes = Math.floor((elapsed % (60 * 60 * 1000)) / (60 * 1000));
      const seconds = Math.floor((elapsed % (60 * 1000)) / 1000);
      
      runtimeCounter.textContent = `${days.toString().padStart(2, '0')}:${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      
      setTimeout(updateRuntimeCounter, 1000);
    }
    
    updateRuntimeCounter();
    
    // Show navigation when scrolling
    const commandNav = document.querySelector('.command-nav');
    
    window.addEventListener('scroll', function() {
      if (window.scrollY > 100) {
        commandNav.classList.add('visible');
      } else {
        commandNav.classList.remove('visible');
      }
    });
    
    // Scroll to section on nav click
    const navButtons = document.querySelectorAll('.command-nav button');
    
    navButtons.forEach(button => {
      button.addEventListener('click', function() {
        const targetId = this.getAttribute('data-target');
        const targetElement = document.getElementById(targetId);
        
        window.scrollTo({
          top: targetElement.offsetTop - 80,
          behavior: 'smooth'
        });
      });
    });
    
    // Project visibility on scroll
    const projects = document.querySelectorAll('.project');
    
    function checkProjectVisibility() {
      projects.forEach(project => {
        const rect = project.getBoundingClientRect();
        const isVisible = rect.top < window.innerHeight * 0.8;
        
        if (isVisible) {
          project.classList.add('visible');
        }
      });
    }
    
    window.addEventListener('scroll', checkProjectVisibility);
    checkProjectVisibility(); // Check initially
    
    // Export Button Functionality
    document.getElementById('export-btn').addEventListener('click', function() {
      // Create a copy of the canvas with current visualization
      const exportCanvas = document.createElement('canvas');
      exportCanvas.width = canvas.width;
      exportCanvas.height = canvas.height;
      const exportCtx = exportCanvas.getContext('2d');
      
      // Draw current canvas state
      exportCtx.drawImage(canvas, 0, 0);
      
      // Add text
      exportCtx.font = '20px "JetBrains Mono", monospace';
      exportCtx.fillStyle = '#ffffff';
      exportCtx.fillText('Generated Algorithmic Art by Geva Kipper', 20, 30);
      
      const timestamp = new Date().toLocaleString();
      exportCtx.font = '14px "JetBrains Mono", monospace';
      exportCtx.fillText(`Created on ${timestamp}`, 20, 60);
      
      // Convert to data URL and trigger download
      const dataURL = exportCanvas.toDataURL('image/png');
      const link = document.createElement('a');
      link.href = dataURL;
      link.download = `algorithmic-art-${Date.now()}.png`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    });
  </script>
<!-- Add this block to embed the like button -->
    <script src="/static/js/like_button.js"></script>
    <script>
        LikeButton.init({
          pageId: "20250404",
          position: "bottom-right", // Options: bottom-right, bottom-left, top-right, top-left
        });
    </script>

</body>
</html>